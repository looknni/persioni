#!/bin/sh

	mdd='mccset' # local 'fccset'
	mddm='mccm'
	mangle='fw4' # local 'filter'
function list(){
	nft list set inet $1 $2
}
function add(){
	case "$1" in
		add )
			nft add element inet $mangle $mdd {"$2"}
			list $mangle $mdd
			;;
		add6 )
			nft add element inet $mangle "${mdd}6" {"$2"}
			list $mangle "${mdd}6"
			;;
		addt )
			nft add element inet $mangle $mdd {"$2" timeout $3}
			list $mangle $mdd
			;;
		addm )
			nft add element inet $mangle $mddm { "$2" }
			list $mangle $mddm
			;;
		addmt )
			nft add element inet $mangle $mddm { "$2" timeout $3 }
			list $mangle $mddm
			;;
	esac
}
function del(){
	case "$1" in
		del )
			nft delete element inet $mangle $mdd {"$2"}
			list $mangle $mdd
			;;
		del6 )
			nft delete element inet $mangle "${mdd}6" {"$2"}
			list $mangle "${mdd}6"
			;;
		delm )
			nft delete element inet $mangle $mddm {"$2"}
			list $mangle $mddm
			;;
	esac
}
case "$1" in
	add | add6 )
		add $1 $2
		;;
	del | del6 )
		del $1 $2
		;;
	addm )
		add $1 $2
		;;
        addt |addmt )
                add $1 $2 $3
                ;;
	delm )
		del $1 $2
		;;
esac
unset mdd mddm mangle

function iconf(){
uci set firewall.@defaults[0].synflood_protect='1'
uci set firewall.@defaults[0].flow_offloading='1'
uci set firewall.@defaults[0].flow_offloading_hw='1'
# uci set firewall.@defaults[0].drop_invalid='1'
uci set firewall.@zone[1].network='wan wwan'

uci set firewall.@rule[0].enabled='0'
uci set firewall.@rule[1].enabled='0'
uci set firewall.@rule[2].enabled='0'
uci set firewall.@rule[3].enabled='0'
uci set firewall.@rule[4].enabled='0'
uci set firewall.@rule[5].enabled='0'
uci set firewall.@rule[6].enabled='0'
uci set firewall.@rule[7].enabled='0'
uci set firewall.@rule[8].enabled='0'

# uci set system.@system[0].hostname='xx'
uci set system.@system[0].timezone='HKT-8'
uci set system.@system[0].zonename='Asia/Hong Kong'
uci set system.ntp.enable_server='1'
uci set system.ntp.interface='lan'

# uci set dropbear.@dropbear[0].PasswordAuth='off'
# uci set dropbear.@dropbear[0].RootPasswordAuth='off'
# uci set dropbear.@dropbear[0].Port='22'
uci set dropbear.@dropbear[0].Interface='lan'
uci set network.lan.dns='114.114.114.114'

uci set network.lan.ip6assign='disabled'
uci set dhcp.lan.ra='disabled'
uci set dhcp.lan.dhcpv6='disabled'

uci set network.wwan=interface
uci set network.wwan.proto='dhcp'

uci set wireless.radio1.cell_density='0'
uci set wireless.radio1.country='US'
uci set wireless.radio1.beacon_int='100'
uci set wireless.radio0.cell_density='0'
uci set wireless.radio0.country='US'
uci set wireless.radio0.beacon_int='100'

uci set wireless.wifinet0=wifi-iface
uci set wireless.wifinet0.device='radio0'
uci set wireless.wifinet0.mode='sta'
uci set wireless.wifinet0.network='wwan'
uci set wireless.wifinet0.ssid='Openwrt'
uci set wireless.wifinet0.bssid='00:00:00:00:02:01'
uci set wireless.wifinet0.encryption='psk2'
uci set wireless.wifinet0.key='12345678'
# uci set wireless.wifinet0.ieee80211w='1'
uci set wireless.wifinet0.wmm='1'
uci set wireless.wifinet0.disabled='1'

uci set wireless.wifinet1=wifi-iface
uci set wireless.wifinet1.device='radio1'
uci set wireless.wifinet1.mode='sta'
uci set wireless.wifinet1.network='wwan'
uci set wireless.wifinet1.ssid='Openwrt'
uci set wireless.wifinet1.bssid='00:00:00:00:02:01'
uci set wireless.wifinet1.encryption='psk2'
uci set wireless.wifinet1.key='12345678'
# uci set wireless.wifinet1.ieee80211w='1'
uci set wireless.wifinet1.wmm='1'
uci set wireless.wifinet1.disabled='1'
uci commit
}
if [ "$1" == "iconf" ];then
	iconf
fi

if [ "$1" == "init" ];then

	nft flush ruleset
	na='prerouting'
	nb='input'
	nc='forward'
	nd='output'
	ne='postrouting'
	raw='raw'
	nat='nat'
	filter='filter'
	mangle='mangle'
	pa=-300
	pb=-100
	pc=0
	pd=-150
nta="$raw $nat $filter $mangle"
for i in $nta;do
	nft add table inet $i
done
unset nta
function nch(){
	nft add chain inet $1 $2 { type $3 hook $4 priority $5 \; policy accept \; }
}
nch $raw $nd $filter $nd $pa
nch $raw $ne $filter $ne $pa
nnat="$na $nb $nd $ne"
for i in $nnat;do
	nch $nat $i $nat $i $pb
done
unset nnat
chainf=(faa fbb fcc)
chainm=(maa mbb mcc mdd mee)
fnn=($nb $nc $nd)
mnn=($na $nb $nc $nd $ne)
mset=(maaset mbbset mccset mddset meeset)
fset=(faaset fbbset fccset)
fmap=(faamap fbbmap fccmap)
for i in {0..2};do
	nch $filter ${fnn[i]} $filter ${fnn[i]} $pc
	nft add chain inet $filter ${chainf[i]}
	nft add rule inet $filter ${fnn[i]} counter jump ${chainf[i]}
	nft add set inet $filter ${fset[i]} { type ipv4_addr \;flags interval,timeout \; counter \;}
	nft add set inet $filter "${fset[i]}6" { type ipv6_addr \;flags interval,timeout \; counter \;}
	nft add rule inet $filter ${chainf[i]} ip daddr @${fset[i]} drop
	nft add map inet $filter ${fmap[i]} { type ether_addr : verdict \; flags interval,timeout \; counter \;}
	nft add rule inet $filter ${chainf[i]} ether saddr vmap @${fmap[i]}
done
for j in {0..4};do
	nch $mangle ${mnn[j]} $filter ${mnn[j]} $pd
	nft add chain inet $mangle ${chainm[j]}
	nft add rule inet $mangle ${mnn[j]} counter jump ${chainm[j]}
	nft add set inet $mangle ${mset[j]} { type ipv4_addr . inet_service \;flags interval,timeout \; counter \;}
	nft add rule inet $mangle ${chainm[j]} ip saddr . tcp dport @${mset[j]} drop
done

# nft add chian inet $filter syn_flood
# nft add rule inet $filter syn_flood limit rate 25/second burst 50 packets counter return comment "water"
# nft add rule inet $filter syn_flood counter drop comment "drop_flood"

unset chainf chainm fnn mnn mset fset fmap
unset na nb nc nd ne raw nat filter mangle pa pb pc pd
nft list ruleset
fi
